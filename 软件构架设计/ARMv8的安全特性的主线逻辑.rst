.. Kenneth Lee 版权所有 2019-2020

:Authors: Kenneth Lee
:Version: 1.0

ARMv8的安全特性的主线逻辑
*************************

介绍
=====
昨天定义“主线逻辑”（:doc:`主线逻辑` ）的时候，做了一个感慨，觉得：

        | 说起来，也可以说这其实就是软件领域的“主要矛盾”，和“矛盾的主要方面”

今天想了一下，发现这个总结是不对的。“主要矛盾”和“矛盾的主要方面”，是客观的，是
现实世界呈现的特点。而“主线逻辑”其实是“主观”的，是“架构师向什么方向牵引这个世界
以达成他的目的”。当然这两者通常有很大的灰度部分，但“名字”本身指向的那个“客体”，
是不一样的。

本文用ARMv8的安全特性来进一步说明“主线逻辑”的内涵。

本文所讨论的内容都是对网络上公开资料的总结，不涉及任何商业机密。

正文
=====

开始看ARM的安全特性，很多人会很头晕（至少我自己就是这样，我用这个问题问过其他人
，无论是硬件还是软件的，几乎没有见过能完全弄清楚这个问题的人），CPU的TrustZone
，Secure Mode，GIC的group 0, group 1， SMMU的安全态可设置寄存器，ATF等等等等，
都会提到安全态的时候的行为是如何的，非安全态的行为是什么的。你很难理解，ARM构架
的构架师背后是用什么逻辑来判断：这样这个系统就是安全的，那样这个系统就是不安全
的。你做一个ARMv8构架的SoC，或者硬件单板，怎么遵循这些规则？又怎么知道下一个版
本中，哪些是架构师会升级的，哪些是他们不会升级的呢？

那你就要抓到架构师维护这个特性的主线逻辑。因为架构师肯定有一个核心逻辑在支撑他
判断：这个特性是可被接受的，那个特性会引入安全问题，是不可接受的。

安全是对业务信息的保护，脱离业务没有安全可言。而平台（比如计算机，芯片构架等）
只是对业务的安全提供基础功能，让业务有机会实现对信息的保护而已。平台提供的这种
基础功能，核心就是隔间。

这好比你吃饭付款，用信用卡刷卡，你在店员面前输密码，要用手遮住键盘，你的手，在
你的视线和其他人的视线之间创建了一个“隔间”。

平台为你创建隔间，就是保证你在隔间内干的活，不会被别人看见，你只对外提供你想提
供的信息。

最原始的隔间手段是物理隔离，比如这样：

        .. figure:: _static/ARM安全.jpg

系统的各个硬件，什么NVME，时钟源，内存，PCIE RC，Cache强行指配到不同的区域中，
要信息跨越安全区，就必须经过安全通讯通道，只要控制住安全通讯通道可以通过的信息
，就构成两个隔间了，你在隔间里怎么弄，都不用担心信息泄露到另一边。（当然还有可
能会有你没有想到的侧信道攻击，但侧信道攻击的难度也高多了）

比如你手机的指纹，都放安全区里，我只告诉你指纹匹配了没有，我怎么比较的，比较的
时候用的计算内存，其中用到了某个随机数做加密，涉及的时钟源，都在安全区中，你不
要指望来访问，这就制造了一个安全区。

这种方法的缺点是两边的资源分配是静态的，不灵活，但其实名称空间是最简洁的。使用
者也好控制，想好你的关键数据怎么放就好了。

灵活一点的方法是CPU的特权级模型：

        .. figure:: _static/ARM安全1.jpg

这同样形成很多的隔间，而且每个隔间都可以占据整个CPU的算力（只要更高特权级允许）
。

这种方法灵活，但接口面大了，攻击的机会就多了。而且它是提供给软件专用的，外设不
可能这样，因为外设上也没有软件啊（一定程度上可以这样认为）。

所以，ARM的手段是把这两者融合，构造这样一个安全模型：

        .. figure:: _static/ARM安全2.jpg

为了让软件部件可以被封闭在外设特定的安全区还是非安全区里面，ARM构架给CPU核在特
权级之外加了另一个控制状态，叫安全模式。这样整个CPU就被分成了8个隔间：特权级
EL(4个状态，EL0-3）*安全S（两个状态，S和NS）。

当软件从其中一个隔间发出请求的时候，如果它是NS的，外设安全区拒绝这个请求（在请
求地址中加一个软件不可控制的信号就可以了）。这样，对外设的控制，就变成高特权级
软件部件对低特权级的软件部件的授权问题了。我启动一个虚拟机，把它放到非安全区里
。无论你发出什么请求，硬件上你就访问不到安全区，这样就为软件构造了一个隔间，保
证它无法越过边界。

如果外设对CPU发出中断，CPU必须判断这个中断是从哪个区发出的，强行把CPU从一个隔间
切换都其他隔间，保证这个处理是在合适的隔间内处理的，这样软件部件之间的隔离就得
到保证了。而CPU要给IOMMU设置页表，也需要根据IOMMU所在的隔间，决定是谁可以设置的
，谁不能设置的。

这就是整个ARM安全设计的“主线逻辑”。而具体GIC的中断在group 0的时候如何Route给FIQ
，何时会切换CPU的特权级和安全状态，这些——请注意，不叫“加花”——这些叫主线逻辑的“
细节”（他们不违背主线逻辑，而是补充主线逻辑），所有的逻辑细节都是为主线逻辑服务
的。

什么叫“加花”呢，如果我们还有一个“极密安全区”，这个安全区只允许S-EL3和S-EL0外加
请求的包符合某个秘钥的签名的软件访问，其他访问都会导致停机。这种类型的逻辑加进
来，就叫“加花”了。因为他一定程度上和主线逻辑不一样。
