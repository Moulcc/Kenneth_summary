.. Kenneth Lee 版权所有 2021

:Authors: Kenneth Lee
:Version: 1.0
:Date: 2021-11-26
:Status: Draft

逻辑哲学论分析
**************

前言
======

这个专栏用于写对逻辑哲学论逻辑链的分析。

我是在写“道德经直译”专栏的时候别人推荐我看的维特根斯坦的理论的，他们说我的观点
（其实我认为是老子的观点了）和维特根斯坦很像，我就很有兴趣去看看。

这本书不容易看懂，因为逻辑链特别长，而且里面涉及了不少罗素，弗雷徳等哲学家的其
他理论，所以我花了不少时间才初步抓到维特根斯坦要解决的问题的要点。这里的文字也
反反复复重写了很多次，经常都是颠覆性的逻辑重建。但我觉得这些工作对我个人来说是
值得的，因为在这个阅读的过程中，我发现了越来越多的我们今天计算机领域，特别是编
程语言领域基本概念的起源。所以，从不同的角度对这本书讨论的问题进行总结，就很有
价值了。

我看书尽量希望看原文，特别是哲学，构架，标准，计算机一类的书，否则翻译者的水平
会成为原始信息的过滤器。

我给各位读者一个鲜活的例子。

在看这本《Tractatus Logico-Philosophicsu》的时候的时候，我看到里面使用了一个概
念：Truth-Function。我不知道它是什么意思。图方便，我查了一下中文维基上的解释，
它是这样的：

        | 在逻辑中，真值函数是从语言的句子生成的函数。
        | 它采用来自 {T,F} (就是真实和虚假)的真值。
        | 例如句子 A → B 生成真值函数 h(A,B)，它的真值是 F，
        | 当且仅当 A 的值是 T 而 B 的值是 F。
        | n 个变量的命题句子生成 2^{2^n} 个真值函数。
        | 比如，如果有像 A → (B → A) 这样的 2 个变量的命题则有 16 个生成的
        | 真值函数。陈述或命题被称为是真值泛函的，如果它的真值由它的部件的
        | 真值来决定。 
        | ...

各位读者可以停下来，好好想想，你是否知道它在说什么？反正我是看不懂，我也找了身
边的人来看，他们也看不懂。

然后我们看看英文版的：

        | In logic, a truth function is a function that accepts truth values
        | as input and produces a unique truth value as output.
        | In other words: 
        | The input and output of a truth function are all truth values;
        | a truth function will always output exactly one truth value;
        | and inputting the same truth value(s) will always output the same
        | truth value.

我都不用看完，作为一个计算机工程师，看第一句我就清楚知道这是什么了。当然，我也
只是知道它的内涵，不看后面的介绍，我不能理解这个定义的外延，但至少内涵已经定义
得非常清楚了。反观前面那个中文版本，我都不知道它在说啥。

这个不是中文表达能力的问题，纯从翻译的角度，甚至你都不能说这个翻译是错的。它只
是把英文版本的内容不分重点，不分范围地放了上来。

因为翻译者根本就不懂这个领域，他不知道这些表述在解决什么问题。所以换一种表达的
时候，他被这种新的语言的自身混沌的部分左右了原文想要强调的东西，他突出了非关键
的信息，没办法突出问题的主题，最终你就完全不知道这个翻译在表达什么了。因为在这
个新的逻辑闭包中，逻辑无法维持连续，信息传递就失败了。

所以维特根斯坦的书，我也希望看原版。问题是，我不会奥地利语（据说一开始是德语？
不知道，反正不是英语）。所以，只能求其次了，找一个同是西方语系的英文版本翻译来
看吧（关键是这个翻译者本身就是个哲学家），所以我最终选的是这个版本：

        | 《Tractatus Logico-Philosophicsu》，
        | Writen by Ludwig Wittgenstein，
        | Translated by D. F. Pears and B. F. McGuinness
        | With an introduction by Bertrand Russell.

我假设看本文的读者是看过维特根斯坦的定义本身的。这个定义很短，有点像《道德经》
那样的长度，风格其实也很像，都是通过直接下断言这种形式来描述观点，所以，要看完
还是很快的。就是要搞清楚他那些基本定义的范围非常困难。也需要像道德经那样反复进
行前后对应。

基于读者都看过原文这个假设，我不会解释什么叫“定义1.1 1”，也不会把所有的原文定义
全部拿上来，只是尽量去抽取其中和我分析目标相关的关键表述。我在作出自己表述的时
候，会去对应这个表述是否和原文的其他细节冲突，但我不会写出所有这些证据，这个动
作需要读者自己去做。

分析方法
========

我是个软件架构师，我的大部分工作都是抽取一个复杂系统的抽象。我通常用的方法是用
不同的目标作为基线，对这个被分析系统针对这个目标的相关特征进行抽取。这个被分析
的系统就会被收缩为一组“\ :doc:`逻辑闭包<../软件构架设计/逻辑闭包>`\ ”，之后再把
这些逻辑闭包抽象出来的名字作进一步的收缩，这样逐步收缩下去，这个系统的细节逻辑
和我对它的抽象就对应起来了。

网上有一个Maynard Handley先生写的关于Apple M1芯片的分析材料，很有名，叫\ *M1
Explainer*\ 。他完全从一个非M1设计者的角度分析M1的设计思路，他的手法和我这个是
类似的，所以我也想用他的表述来增强我这个意思，他的说法是：

        | As I have said, I've written and rewritten, experimented and
        | re-experimented, with this section rpeatedly. I would come
        | up with a general theory of how it all fitted together, then
        | realize all my probes did not test and alternate explanation,
        | run a new set of tests, and again be surprised.

所以，我这里也有他那个号召：

        | If someone else has a better theory of how it all fits together,
        | or advises a different set of experiments showing a flaw in my
        | analysis, or even realizes I made a mistake in some of the
        | experiments (it happens! especially when you have no idea what
        | to expect, what counts as an unexpected result), please help
        | advance our common understanding.

希望读者能给我提供你的观察，以便“Advance our common understanding”。

维特根斯坦研究的问题
====================

我们用我们在《道德经》分析中建立的逻辑空间来看待维特根斯坦研究的问题。

我们通过“名”来思考问题，名是一个抽象，是我们“结构化思维”的最小单位，但名是被细
节所解释的。这就好像在机器学习中，你用来训练的数据集（比如一千张猫的照片）是无
法被逻辑化去思考的，你要思考就只能用“猫”这个名字。所以，计算机的图灵机部分，要
进行if...else, while, then，这些判断，都必须使用结构化数据，使用数字化后的结果
比如：“如果有猫通过本区域启动告警”，这句话本身，如果我们不解开猫是什么这件事，
仅仅谈它表达的逻辑，这是精确的，可逻辑化的，可以用编程逻辑来描述的。这是结构化
思维的部分，而猫的照片，对我们来说就没有逻辑可言，就是一片混沌。这就是道德经中
说的“恍惚”，也是现在我对维特根斯坦这句话的理解：

        | What can be said at all can be said clearly,
        | and what we cannot talk about we must pass over in silence.

.. note::

  我还看了网上一些英美的哲学老师的课程，发现也有人认为这句话不是这样翻译的，而
  是：What we cannot talk we should keep sinence。这听起来好像是一种鸡汤，我不
  认为一个哲学家，特别是讨论“逻辑”的哲学家，会不讲规律而去讲道德，所以我是不认
  可这种理解的。

我们能说清楚的，就是“名”，说不了的，就是混沌，混沌无法通过语言去传递，只能在
silence中彼此认可。你也看过猫，我也看过猫，我们就可以用猫（这个名字）来传递信息
，但猫本身的那些细节，无法被传递。当然，你还可以对猫的细节进行分类，但你永远都
会剩下无法传递的部分。

作为印证，前面这句话后面，维特根斯坦是这样说的：

        | Thus the aim of the book is draw a limit to thought or rather
        | -- not to thought, but to the expression of thougth, we should
        | have to find both sides of the limit thinkable.

每个名都可以被无限维度，无限空间地进行细分，这些细分的名，一同定义了这个抽象的
名本身。所以，高层的名，是一个细节的名的集合。直到我们只能通过Silence传递到
Atomic的名上面。

所以，我们拆解一个构架，比如“逻辑哲学论”，我们唯一的方法是拆解它下一层的名，看
我们拆出来的名本身能否逻辑自恰（这个抽象的名，和它被拆出来的名共同构成一个逻辑
闭包），以及这些逻辑是否和维特根斯坦自己的描述一致。这也是我拆《道德经》的方法
，我对自己的这个拆解结果是比较自信的，因为我拆解结果，逻辑之间都是自恰的，不像
某些人那样，这几句话是谈管理，那几句话是谈军事，完全连不到一起。你永远没有办法
问一个作者他说的话是什么意思，但如果一个抽象还能被使用和传递，它的逻辑是统一的
，这是唯一的判断标准。

《逻辑哲学论》的定义比较“长”。这里说它长，不是文字长度意义上的，而是程序员眼中“
一个函数有3000行”那种意义的长。程序员都知道，一个程序有几万行，几百万行，都还容
易看懂，但如果一个函数有几千行，就很难看懂了。因为我们组织逻辑的时候，能相对独
立抽离的逻辑，我们都会独立放到一个函数中，我们理解一个逻辑，都在一个函数里面，
这样还是比较容易的，其他函数对这个函数来说，只是一个“名”，我们是不管那个“名”的
内部逻辑的。所以，虽然一个程序几百万行，只要每个函数设计的东西不多，这个程序还
是容易看懂的，但如果你一个函数本身就很长，要理解这个函数的逻辑就很复杂了，人脑
不擅长处理这种东西。

逻辑哲学论就是这样弄的，一个概念的定义可以十几页，你都没法抽象它原始的含义，就
算他实际上也组织成一个层次结构，你都不好完整地理解它。比如我给你一句简单的话：

        如果维特根中心斯坦的中间序列对他的反身代谢逻辑弧构成一个不来梅等比逻辑，
        那么这个中间序列对这个逻辑弧的几何重心具有溶解性质。

虽然这个表述倒是很短，但里面每个概念都要看很长的一个定义你才知道他说什么，这就
很难看懂了。

我这里要做的是，在他刚开始定义那个概念的时候，就把他打算描述的那个具像拿出来，
作为后面阅读的一个标记，这样我们就可以反复去对比这个标记，确认我们没有迷失我们
的方向。

维特根斯坦认为，恍惚的部分是无法被描述的，所以只要你开始交流，开始传递，就必然
是一个结构化数据。这个概念我用两个类似的定义帮助读者理解：

其一，道德经里的道和名的关系。世界的客观存在，是道，你也能感受到它，你能看它，
你能听它，但你没法说它，因为你“说”这件事，其实是用“语音”这个媒介，去“部分贴近”
你对世界的那个感受（Sense），这已经转意了。所以，名不是不可名，道也不是不可道，
但两者不是全等的。

这不但体现为语言，同样体现为文字，体现为脑子里面的思考。

.. note::

  有个很有趣的问题，在中国的文化中，常常用道表示高度抽象，而用器表示具像。而道
  德经中，道是全部，而不是抽象。这好像完全反了，但其实它们是不矛盾的。道就是全
  部，但全部没法说，所以，抽象得最好的名，就成了道的代表，而抽象得不好，关注不
  了最重要本质的名，就被叫器。

  “写好程序最重要是控制好数据之间的关系”，这给人的感觉就是道，因为它总结得比较
  好。而“写好程序就要知道libc的API列表”，这给人的感觉就是器，因为换一种编程语言
  这个抽象就不怎么成立。但“写好程序最重要是控制好数据之间的关系”绝对代表不了写
  程序的所有方面，这不是道德经中的道，但要描述写程序所有的细节，你也没法说的清
  楚，所以道的本质就是大，大就逝，逝就说不清楚了。道就只能Pass over in silence。

自然数不代表{0, 1, 2, 3...}，但你也不能说{0, 1, 2, 3...}不是自然数。“自然数”只
是一个“名”，{0, 1, 2, 3...}暂时在我们这个上下文中可以说更接近道。但你要说，你就
只能说自然数，你说不了所有的自然数。所以道德经只能这样说：道曰大，大曰逝，逝曰
远，远曰反。他也就能说到这个程度了，剩下的，你就只能Pass over in silence（这个
概念经常要用，我给它一个缩写，叫POIS）。

其二，我们可以从机器学习的角度来理解这两个概念：

我们一般把计算机逻辑判断的部分，叫结构化判断。比如，我们一般程序是这样写的（不
懂程序不要紧，懂英语就行，当一个（人对计算机的）工作指导看就行）：

.. code-block:: python

  def the_action(object):
    if object is CAT:
      play("喵")
    else if object is MOUSE:
      play("吱")
    else
      play("咕噜咕噜")

这里def定义了一个函数，这个函数的输入是一个object，它对object进行判断，如果这个
object是只猫，就播放“喵”这个声音，如果是老鼠，就播放“吱”这个声音，否则，就播放“
咕噜咕噜”这个声音。

这些判断，在我们的认知中，是精确的，我们可以进行判断的，要不选左，要不选右的。
传统计算机最擅长的就是干这种事情了，这部分就叫结构化信息处理。

而机器学习就不同了，机器学习给计算机提供一只猫的图片，或者声音，气味的（大量）
数据，然后问“这是什么？”，然后计算机给你一个答案：这是一只猫。

这里猫就是一个名，而那些什么图片，声音，气味之类的东西，就是“道”，或者说更贴近
道（因为还可以细分），它的本质就是“大”，大到你没法在语言和思考中罩住它。

下面这个图是Tensorflow（一个非常著名的机器学习的平台）教程的一个例子，叫fashine
mnist，用101700个参数表达对一组时尚物品图标的认知：

.. figure:: _static/fashine_mnist.png

它每次给进去一副图，算法用101700个参数来计算一个输出（就是旁边那幅坐标系的图），
图标很复杂，也没有什么逻辑，那幅坐标系给出的结果就很简单，鞋子就是7，衣服就是
4……图标本身就是POIS，而数字就是逻辑的部分。

无论是什么吧，对人脑的某个时刻，我们有一部分是进行结构化处理的，有一部分完全是
个恍惚，你觉得你看见了它，但你的结构化信息里面没有它。那个部分对结构化信息处理
来说，不存在，只能POIS。

而逻辑哲学，就是放弃了POIS的部分，把POIS当作黑盒，仅讨论结构化信息如何利用的那
部分逻辑的建模。在这个专栏中，我把这部分的信息，称为Tractatus。

也就是说，Tractatus对应道德经中的“名”，计算机中的结构化数据；POIS对应道德经中的
“道”，计算机中的非结构化数据。但我们不能说它们完全相同。

为了能够割裂Tractatus和POIS，维特根斯坦完全消除了Tractatus对POIS的依赖，而用一
个名字怎么“用”，来定义这个名字本身。如果你的逻辑判断（请具像地联想一下前面的程
序）用到了一个对象的属性，那么这个属性就是这个对象的一部分，如果你没有用到这个
属性，它就不是，这个对象当初被定义时所使用的原始的POIS，不是问题的一部分。

这样，Tractatus就可以完全在“逻辑”的范围内讨论问题了，不需要在去纠缠“这是不是我
说的那个东西”。所以，Tractatus和道德经是完全不同的学问。Tractatus讨论的是纯粹的
“名的规律”，而道德经讨论的是“名被道影响的规律”。

让我们这样想这个问题：

在Tractatus中，如果你整个逻辑判断模型是：

        | 这是狗，它会叫，会吃，会生后代，可以豢养

然后你还有一个判断模型：

        | 这是猫，它会叫，会吃，会生后代，可以豢养

对于Tractatus来说，这就是同一个东西，我判断不了你当时看见这种东西那个POIS是什么
，但在你这个逻辑世界中，这就是同一个东西。

而道德经不是这样想这个问题的，道德经一直想的是，你认为：

        | 这是X，它会叫，会吃，会生后代，可以豢养

这个概念现在是这样的，它一直是这样吗？它发展起来的规律是什么样的？如果人们开始
因此定义了“狗肉好吃”，那么这些条件就不会是这些条件，我们会从那个集合中抽取其他
的属性。所以，求强就要处弱，求好就要面对坏。它一直讨论的是“道”对“名”系统的输入
和改变。而逻辑哲学讨论的是：现在我们停止POIS对Tractatus的输入，Tractatus呈现什
么样的特征。

.. note::

  所以，逻辑哲学论还有一个补充逻辑：如果你认为两个属性一样的对象不同，那么
  它们唯一的不同是“它们是不同的”这个属性。这算是对这个理论缺陷的一个提醒：
  你并没有暴露全部的POIS信息，这些信息是可以变的，只是我们的逻辑世界不观察
  它而已。

所以，前面提到的这个Truth Function就很重要了。因为所有有效的逻辑判断，最终都只
反映为“在集合中”和“不在集合中”，或者说“属性匹配”和“属性不匹配”这种判断。那么，
我们就可以把所有的的观点（Proposition），看作是原子定义（Atomic，再分解就成为
POIS的概念）的一种组合（Complex）。而这个组合方法，就是Truth Function。Truth
Function接受Truth Function自己作为输入，比如“猫会上树”，这是一个Atomic；“狗会游
泳”，这也是一个Atomic，那么我们组合一下，“狗会游泳而且猫会上树”，这是用真值函数
“而且”组合出来的一个Complex。如果我们知道两个Atomic的真假，我们也就知道了这个
Complex的真假了。如果所有的Complex都是通过真值函数来组合的，那么，我们就可以清
晰描述我们所有Tractatus要描述的问题。

为此，维特根斯坦还特意去解决了罗素悖论中的问题，不允许把一个Truth Function自己
作为自己的输入。这里的关键就是他前面那个定义：一个名称被它的所有用法所定义，所
以，如果一个真值函数的输入中包括了它自己，那么它自己作为它的输入定义了一个新的
真值函数。所以，不存在F(Fu)，因为F本身不能作为F的输入，它要求写作：
:math:`(\exists\psi):F(\psi\ u).\psi\ u=Fu` 。这里把内层的Fu另外定义成
:math:`\psi`\ ，让F的定义变成加上\ :math:`\psi`\ 的定义，把两者分开了。

.. note::

  这里这个描述让我pending了很久，因为不知道这个.是什么，也不知道它的优先级是什
  么。一直看到最后，我才知道这是and，优先级在整个表达式中最低。

逻辑哲学这个基本的概念，也告诉了我们一个最基本的信息传递的原理。信息的传递是由
发送方和接收放共同决定的。这也是道德经中说的混沌的原理：视而不见，听而不闻，博
之不得。为什么会这样？因为你接受这个“POIS”的那个模型中，没有抽取这个信息。

我给你一张纸条，里面证明了哥德巴赫猜想，你拿起来就上厕所了：我希望传递的信息是
哥德巴赫猜想，你提取的信息是“这东西可以擦屁股”。所以，定义你的世界不是这个世界
的全部，而是你建立的那个模型。这也是我这里写这么多的原因，我给你抽象这么多概念
然后建立一个可以对细节信息进行“真”，“假”判断的模型，没有这个模型，所有文字都只
会变成“文字”这个名字，抽取不出其他有效信息的。

另一个值得关注的问题是可能性。这个问题对于中国人来说也非常有趣。对于西方人来说，

        **If** I work hard, **then** I will be promoted.

如果把I work hard定义为p，I am promoted定义为q，那么这句话在逻辑上表示为：

        p->q

念做“p imply q”。它和“~p v q”是等价的。所以，在英文中，上面这句话可以这样说：

        **Either** I don't work hard，**or** I am promoted.

这背后是这样一张真值表（T表示True，F表示False，v表示or）：

.. _`pq真值表`:

.. table:: p->q和~p v q真值表

  +---+---+------+----+--------+
  | p | q | p->q | ~p | ~p v q |
  +===+===+======+====+========+
  | T | T |  T   | F  |    T   |
  +---+---+------+----+--------+
  | T | F |  F   | F  |    F   |
  +---+---+------+----+--------+
  | F | T |  ?   | T  |    T   |
  +---+---+------+----+--------+
  | F | F |  ?   | T  |    T   |
  +---+---+------+----+--------+

我们推想一下：

如果p为真，就会有q为真，那么我们是否可以说“p可以推出q”？可以。所以“p->q”为真；
同样p为真q为假，“p->q”不成立，所以是F。但如果p是假，那么我们能否说p可以推出q呢
？这在中文里是“不知”，这个地方无定义。

但在西方哲学中，他们认为可能性存在，就没有拒绝，所以这都可以看作是真。一旦我们
这样看这个问题，p->q和~p v q就是等价的。所以他们说“Either I don't work hard, or
I am promoted.”等价于说：“只要我努力工作，我就能被升职”。

但我们中文是没有这个表达的，我们可以说：“如果我努力工作，我就能升职”，或者“如果
我不努力工作，我就升不了职”。我们是直接排除掉p=F的情形的。我们要非常小心这个地
方的陷阱。西方哲学用集合来看待每个描述表达的范围，因为当我们说p->q的时候，p本来
就不是q的全部原因，这只是一种可能性，或者说一种相关性。所以，可能性存在就可以用
于和其他集合进行交集运算，所以不能排除“可能存在”的集合范围的。这就是为什么维特
根斯坦说“一个fact包含所有的可能性”。因为西方逻辑就是这样定义True的，称为
Truth-possibility（4.4 4）。

如果读者熟悉“函数式编程”，这可以理解得更加具像：

从计算机的角度来说，输出是一个计算机可以输出的所有值的全集，然后我们加上各种限
制条件，不断收缩它的取值范围，最后得到的就是它的输出。比如一个函数：

.. code-block:: haskell

  my_algorithm :: Object a => a -> a -> a -> a
  my_algorithm a b c = a + b - c

照顾不熟悉Haskell的读者——这段程序定义了一个函数my_algorithm，返回a+b-c。用函数
编程的观点说，当我们没有给a, b, c任何值的时候，它的输出范围已经被限制在一定的范
围內了。这个范围，由如下定义共同确定：

* a的范围
* b的范围
* c的范围
* +的范围
* -的范围
* a+b-c这个形式结构

这个输出不是一个值，而是一个很大的范围。Haskell计算这个结果的方法叫咖喱化，比如
我们先把a=3输进去，my_algorithm_3的定义就修改了，变成：

.. code-block:: haskell

  my_algorithm3 :: Object a => a -> a -> a
  my_algorithm3 b c = 3 + b - c

这个可以取值的范围变窄了，如此类推，当我们把c的值也输进去了，这个结果就是一个独
立的数字。

所以，对于函数编程，所有变量，函数，操作符，全部都是一样的东西，都是范围和对范
围组合方法的要求。所以，“有可能”是一种True，你要把那个可能性排除，只需要加入一个
新的条件就可以了。

独立讨论主题
============

.. toctree::
   :maxdepth: 1
   :caption: 主题：

   1
   2
   3
   4
   5
   6
   7
